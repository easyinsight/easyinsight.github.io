<?xml version="1.0" encoding="utf-8"?>
<mx:Box xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" 
	xmlns:analysis="com.easyinsight.analysis.*"
	creationComplete="initStuff()" creationPolicy="all" xmlns:formatter="com.easyinsight.analysis.formatter.*">
	<mx:states>
		
		<mx:State name="Measure">			
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<analysis:ColorSelection id="measureRangeSelection"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Formatting: ">								
					<formatter:FormattingSetup id="formattingSetup"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
		
		<mx:State name="ComplexMeasure">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Wrapped Aggregation: ">
					<mx:ComboBox dataProvider="{measureObjects}" id="complexWrappedAggregations"/>
				</mx:FormItem>
			</mx:AddChild>	
		</mx:State>
		
		<mx:State name="TemporalMeasure">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Wrapped Aggregation: ">
					<mx:ComboBox dataProvider="{measureObjects}" id="temporalWrappedAggregations"/>
				</mx:FormItem>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Level:" direction="horizontal">
					<mx:ComboBox id="temporalDateBox">
						<mx:ArrayCollection>
							<mx:Object label="Year" data="{AnalysisItemTypes.YEAR_LEVEL}"/>
							<mx:Object label="Month - Year" data="{AnalysisItemTypes.MONTH_LEVEL}"/>
							<mx:Object label="Day - Month - Year" data="{AnalysisItemTypes.DAY_LEVEL}"/>							
						</mx:ArrayCollection>
					</mx:ComboBox>
				</mx:FormItem>
			</mx:AddChild>	
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date: ">
					<mx:ComboBox dataProvider="{dateFields}" id="dateComboBox" labelField="display"/>
				</mx:FormItem>				
			</mx:AddChild>				
		</mx:State>
		
		<mx:State name="Calculation">
			<mx:RemoveChild target="{aggregationBox}"/>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<analysis:ColorSelection id="calcMeasureRangeSelection"/>
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Formatting: ">								
					<formatter:FormattingSetup id="calcFormattingSetup"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
	
		<mx:State name="Grouping">
            <mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
                <mx:FormItem label="Group: ">
                    <mx:CheckBox id="groupCheckbox"/>
                </mx:FormItem>
            </mx:AddChild>
		</mx:State>
		<mx:State name="Range">
			
		</mx:State>
		<mx:State name="List">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Expanded:" direction="horizontal">
					<mx:CheckBox id="listExpanded"/>
				</mx:FormItem>
			</mx:AddChild>
		</mx:State>
		<mx:State name="Date">
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Level:" direction="horizontal">
					<mx:ComboBox id="dateBox">
						<mx:ArrayCollection>
							<mx:Object label="Year" data="{AnalysisItemTypes.YEAR_LEVEL}"/>
							<mx:Object label="Month - Year" data="{AnalysisItemTypes.MONTH_LEVEL}"/>
							<mx:Object label="Day - Month - Year" data="{AnalysisItemTypes.DAY_LEVEL}"/>							
						</mx:ArrayCollection>
					</mx:ComboBox>
				</mx:FormItem>	
			</mx:AddChild>
			<mx:AddChild relativeTo="{firstForm}" position="after" creationPolicy="all">
				<mx:FormItem label="Date Format:" direction="vertical">
					<mx:TextArea borderStyle="none" borderThickness="0" fontSize="10" width="300" 
						text="The date format is specified by a pattern string. Within the pattern, letters are interpreted as the components of the date string. The following pattern letters are supported:"/>
					<mx:DataGrid fontSize="10" rowCount="3">
						<mx:ArrayCollection>
							<mx:Array>
								<mx:Object letter="y" meaning="Year" example="2008; 08"/>
								<mx:Object letter="M" meaning="Month in Year" example="July; Jul; 07"/>
								<mx:Object letter="d" meaning="Day in month" example="10"/>
							</mx:Array>
						</mx:ArrayCollection>
						<mx:columns>											
							<mx:DataGridColumn dataField="letter" width="48" headerText="Letter"/>
							<mx:DataGridColumn dataField="meaning" headerText="Date Component"/>
							<mx:DataGridColumn dataField="example" headerText="Examples"/>
						</mx:columns>
					</mx:DataGrid>
					<mx:TextInput id="dateFormat" text="yyyy-MM-dd"/>
				</mx:FormItem>
			</mx:AddChild>	
		</mx:State>
	</mx:states>
	<mx:Script>
		<![CDATA[
			import com.easyinsight.analysis.conditions.MeasureConditionRange;
			import mx.events.DropdownEvent;
            import com.easyinsight.analysis.options.OptionFactory;
            import mx.collections.ArrayCollection;

            [Bindable]
            private var aggregationTypeObjects:ArrayCollection;
            [Bindable]
            private var measureObjects:ArrayCollection;
            private var aggregationTypeMap:Object;
            private var _aggregationType:String = "Sum";
            private var startingAnalysisItem:AnalysisItem;
            private var key:Key;
            
            [Bindable]
            private var _fieldNameEditable:Boolean = true;
            
            [Bindable]
            private var dateFields:ArrayCollection = new ArrayCollection();
            
            [Bindable]
            private var displayName:String;
            
            public function set fieldNameEditable(fieldNameEditable:Boolean):void {
            	_fieldNameEditable = fieldNameEditable;
            }
            
            public function set analysisItems(analysisItems:ArrayCollection):void {            	
            	for each (var analysisItemWrapper:AnalysisItemWrapper in analysisItems) {
            		if (analysisItemWrapper.analysisItem.hasType(AnalysisItemTypes.DATE)) {
            			dateFields.addItem(analysisItemWrapper.analysisItem);
            		}
            	}
            }

            public function set analysisItem(analysisItem:AnalysisItem):void {
                this.startingAnalysisItem = analysisItem;
                if (aggregationTypeObjects == null) {
                    aggregationTypeObjects = getAggregationTypeObjects();
                }                
                this.displayName = analysisItem.display;
                this.key = analysisItem.key;
            }
            
            private function indexOfType(option:String):int {
            	if (getGroupingOptions().contains(option)) {
            		return 0;
            	} else if (getMeasureOptions().contains(option)) {
            		return 1;
            	} else if (getComplexOptions().contains(option)) {
            		return 2;
            	}
            	return -1;
            }
            
            override protected function createChildren():void {
            	super.createChildren();
            	measureObjects = getMeasureOptions();
            	if (startingAnalysisItem.hasType(AnalysisItemTypes.CALCULATION)) {
                	currentState = "Calculation";
                	aggregationChange("Calculation");
                } else {
	                var option:String = OptionFactory.getAnalysisItemOption(startingAnalysisItem);
	                var index:int = indexOfType(option);
	                toggleBar.selectedIndex = index;
	                if (index == 0) {
	            		aggregationTypeObjects = getGroupingOptions();            		
	            	} else if (index == 1) {
	            		aggregationTypeObjects = getMeasureOptions();            		
	            	} else {
	            		aggregationTypeObjects = getComplexOptions();
	            	}
	                aggregationBox.selectedIndex = aggregationTypeObjects.getItemIndex(option);
	                aggregationChange(option);
	            }
            }

            private function initStuff():void {
                if (aggregationTypeObjects == null) {
                    aggregationTypeObjects = getAggregationTypeObjects();
                }
                focusManager.setFocus(fieldNameInput);
                addEventListener(KeyboardEvent.KEY_UP, keyedComplete);
            }
            
            private function keyedComplete(event:KeyboardEvent):void {
            	if (event.keyCode == Keyboard.ENTER) {
            		save();
            	}
            }

            protected function getAggregationTypeObjects():ArrayCollection {
                return getGroupingOptions();
            }
            
            protected function getGroupingOptions():ArrayCollection {
            	return new ArrayCollection(["Grouping", "Range", "Date", "List"]);
            }
            
            protected function getMeasureOptions():ArrayCollection {
            	return new ArrayCollection(["Sum", "Average", "Min", "Max", "Count"]);
            }
            
            protected function getComplexOptions():ArrayCollection {
            	return new ArrayCollection(["Delta", "Normality"]);
            }

            public function save():AnalysisItem {
                var analysisItem:AnalysisItem;
                switch (currentState) {
					case "Calculation":
						var analysisCalculation:AnalysisCalculation = startingAnalysisItem as AnalysisCalculation;
						var calcMeasureConditionRange:MeasureConditionRange = calcMeasureRangeSelection.createMeasureConditionRange();
                        if (calcMeasureConditionRange != null) {
                        	analysisCalculation.measureConditionRange = calcMeasureConditionRange;
                        }                                
                        analysisCalculation.formattingConfiguration = calcFormattingSetup.formattingConfiguration;
                        analysisItem = analysisCalculation;
                        break;               	                            
                    case "Measure":
                    	var analysisMeasure:AnalysisMeasure;
                        switch (aggregationBox.selectedLabel) {
                            case "Sum":
                                analysisMeasure = new AnalysisMeasure(AggregationTypes.SUM);
                                break;
                            case "Average":
                                analysisMeasure = new AnalysisMeasure(AggregationTypes.AVERAGE);
                                break;
                            case "Max":
                                analysisMeasure = new AnalysisMeasure(AggregationTypes.MAX);
                                break;
                            case "Min":
                                analysisMeasure = new AnalysisMeasure(AggregationTypes.MIN);
                                break;
                            case "Count":
                                analysisMeasure = new AnalysisMeasure(AggregationTypes.COUNT);
                                break;
                        }
                        var measureConditionRange:MeasureConditionRange = measureRangeSelection.createMeasureConditionRange();
                        if (measureConditionRange != null) {
                        	analysisMeasure.measureConditionRange = measureRangeSelection.createMeasureConditionRange();
                        }                                
                        analysisMeasure.formattingConfiguration = formattingSetup.formattingConfiguration;
                        analysisItem = analysisMeasure;
                        break;
                    case "Grouping":
                        var analysisDimension:AnalysisDimension = new AnalysisDimension();
                        analysisDimension.group = groupCheckbox.selected;
                        analysisItem = analysisDimension;
                        break;
                    case "Range":
                        analysisItem = new AnalysisRangeDimension();
                        break;
                    case "List":
                    	analysisItem = new AnalysisList(listExpanded.selected);                            	
                    	break;
                    case "Date":
                        analysisItem = new AnalysisDateDimension(dateBox.selectedItem.data, dateFormat.text);
                        break;
                    case "ComplexMeasure":
                    	var complexAggregationType:int;
                    	switch (complexWrappedAggregations.selectedLabel) {
                            case "Sum":
                                complexAggregationType = AggregationTypes.SUM;
                                break;
                            case "Average":
                                complexAggregationType = AggregationTypes.AVERAGE;
                                break;
                            case "Max":
                                complexAggregationType = AggregationTypes.MAX;
                                break;
                            case "Min":
                                complexAggregationType = AggregationTypes.MIN;
                                break;
                            case "Count":
                                complexAggregationType = AggregationTypes.COUNT;
                                break;
                        }
                    	switch (aggregationBox.selectedLabel) {
                            case "Normality":
                            	analysisItem = new ComplexAnalysisMeasure(AggregationTypes.NORMALS, complexAggregationType);
                        		break;
                		}
                    	break;
                    case "TemporalMeasure":
                   		var temporalAggregationType:int;
                    	switch (temporalWrappedAggregations.selectedLabel) {
                            case "Sum":
                                temporalAggregationType = AggregationTypes.SUM;
                                break;
                            case "Average":
                                temporalAggregationType = AggregationTypes.AVERAGE;
                                break;
                            case "Max":
                                temporalAggregationType = AggregationTypes.MAX;
                                break;
                            case "Min":
                                temporalAggregationType = AggregationTypes.MIN;
                                break;
                            case "Count":
                                temporalAggregationType = AggregationTypes.COUNT;
                                break;
                        }
                    	switch (aggregationBox.selectedLabel) {
                            case "Delta":
                            	var existingDim:AnalysisDateDimension = dateComboBox.selectedItem as AnalysisDateDimension;
                            	var dateDim:AnalysisDateDimension = new AnalysisDateDimension(temporalDateBox.selectedItem.data,
                            		existingDim.customDateFormat);
                            	dateDim.key = existingDim.key;
                            	analysisItem = new TemporalAnalysisMeasure(AggregationTypes.DELTA, temporalAggregationType,
                            		dateDim);
                        		break;
                		}
                		break;                    	
                }
                analysisItem.displayName = fieldNameInput.text;
                analysisItem.key = key;
                //dispatchEvent(new AnalysisItemEditEvent(analysisItem, true));
                return analysisItem;
                //PopUpManager.removePopUp(this);
            }

            protected function getDefaultStart():String {
                return null;
            }

            

            private function aggregationTypeChanged(event:DropdownEvent):void {
                var newAggregationType:String = event.currentTarget.selectedLabel;
                aggregationChange(newAggregationType);
            }

            private function aggregationChange(newAggregationType:String):void {
                switch (newAggregationType) {
                    case "Sum":
                    case "Average":
                    case "Max":
                    case "Min":
                    case "Count":
                        currentState = "Measure";
                        if (startingAnalysisItem is AnalysisMeasure) {
                        	var analysisMeasure:AnalysisMeasure = startingAnalysisItem as AnalysisMeasure;
                        	if (analysisMeasure.measureConditionRange != null) {
                        		measureRangeSelection.measureConditionRange = analysisMeasure.measureConditionRange;
                        	}
                        	if (analysisMeasure.formattingConfiguration != null) {
                        		formattingSetup.formattingConfiguration = analysisMeasure.formattingConfiguration;                        		
                        	}
                        }
                        break;
                    case "Delta":
                    	currentState = "TemporalMeasure";
                    	break;
                    case "Normality":
                    	currentState = "ComplexMeasure";
                    	break;
                    case "Calculation":
                    	currentState = "Calculation";
                    	if (startingAnalysisItem is AnalysisCalculation) {
                        	var analysisCalculation:AnalysisCalculation = startingAnalysisItem as AnalysisCalculation;
                        	if (analysisCalculation.measureConditionRange != null) {
                        		calcMeasureRangeSelection.measureConditionRange = analysisCalculation.measureConditionRange;
                        	}
                        	if (analysisCalculation.formattingConfiguration != null) {
                        		calcFormattingSetup.formattingConfiguration = analysisCalculation.formattingConfiguration;                        		
                        	}
                        }
                        break;
                    case "Grouping":
                        currentState = "Grouping";
                        if (startingAnalysisItem is AnalysisDimension) {
                            var analysisDimension:AnalysisDimension = startingAnalysisItem as AnalysisDimension;
                            groupCheckbox.selected = analysisDimension.group;
                        }
                        break;
                    case "Range":
                        currentState = "Range";
                        break;
                    case "List":
                    	currentState = "List";                            	
                    	break;
                    case "Date":
                        currentState = "Date";
                        if (startingAnalysisItem is AnalysisDateDimension) {
                            var analysisDateDimension:AnalysisDateDimension = startingAnalysisItem as AnalysisDateDimension;
                            switch (analysisDateDimension.dateLevel) {
                                case AnalysisItemTypes.YEAR_LEVEL:
                                    dateBox.selectedIndex = 0;
                                    break;
                                case AnalysisItemTypes.MONTH_LEVEL:
                                    dateBox.selectedIndex = 1;
                                    break;
                                case AnalysisItemTypes.DAY_LEVEL:
                                    dateBox.selectedIndex = 2;
                                    break;
                            }
                            dateFormat.text = analysisDateDimension.customDateFormat;
                        } else {
                            dateBox.selectedIndex = 0;
                        }
                        break;
                }
            }
            
            private function toggleClick():void {
            	if (toggleBar.selectedIndex == 0) {
            		aggregationTypeObjects = getGroupingOptions();            		
            	} else if (toggleBar.selectedIndex == 1) {
            		aggregationTypeObjects = getMeasureOptions();            		
            	} else {
            		aggregationTypeObjects = getComplexOptions();
            	}
            	aggregationChange(aggregationTypeObjects.getItemAt(0) as String);
            }
        ]]>
	</mx:Script>
	<mx:VBox>
		<mx:ToggleButtonBar id="toggleBar" itemClick="toggleClick()">
			<mx:dataProvider>
                <mx:Array>
                    <mx:String>Grouping</mx:String>
                    <mx:String>Number</mx:String>
                    <mx:String>Complex</mx:String>                    
                </mx:Array>
            </mx:dataProvider>
		</mx:ToggleButtonBar>	
	</mx:VBox>
	<mx:Form id="coreForm">
		<mx:FormItem label="Field Name: " direction="horizontal" id="fieldNameText">
			<mx:TextInput id="fieldNameInput" text="{displayName}" editable="{_fieldNameEditable}"/>
		</mx:FormItem>
		<mx:FormItem label="Field Type: " direction="horizontal" id="firstForm">
			<mx:ComboBox id="aggregationBox" dataProvider="{aggregationTypeObjects}" 
				close="aggregationTypeChanged(event)" rowCount="9"/>
		</mx:FormItem>						
	</mx:Form>
	<mx:StringValidator id="nameValidator" source="{fieldNameInput}" property="text" minLength="3"/>
</mx:Box>
