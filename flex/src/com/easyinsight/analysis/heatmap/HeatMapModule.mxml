<?xml version="1.0" ?>
<mx:Module xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:visualization="com.michaelvandaniker.visualization.*"
           implements="com.easyinsight.analysis.IReportRenderer" initialize="onInitialize()" width="100%" height="100%">
    <mx:Fade id="fadeInEffect" alphaFrom="0.0" alphaTo="0.57" duration="1000" />
    <mx:Script><![CDATA[
        import com.easyinsight.analysis.AnalysisDefinition;
        import com.easyinsight.analysis.CoordinateValue;
        import com.easyinsight.analysis.CustomChangeEvent;
        import com.easyinsight.analysis.DrillThrough;
        import com.easyinsight.analysis.DrillThroughEvent;
        import com.easyinsight.analysis.DrillThroughExecutor;
        import com.easyinsight.analysis.Link;
        import com.easyinsight.analysis.ReportWindowEvent;
        import com.easyinsight.filtering.FilterRawData;
        import com.easyinsight.filtering.FilterValueDefinition;
        import com.easyinsight.report.ReportNavigationEvent;
        import com.google.maps.InfoWindowOptions;
        import com.google.maps.LatLng;
        import com.google.maps.MapEvent;
        import com.google.maps.MapMouseEvent;
        import com.google.maps.MapMoveEvent;
        import com.google.maps.MapType;
        import com.google.maps.MapZoomEvent;
        import com.google.maps.controls.MapTypeControl;
        import com.google.maps.controls.PositionControl;
        import com.google.maps.controls.ZoomControl;
        import com.google.maps.interfaces.IMapType;
        import com.google.maps.interfaces.IOverlay;
        import com.google.maps.overlays.Marker;
        import com.michaelvandaniker.visualization.GradientDictionary;
        import com.michaelvandaniker.visualization.HeatMap;
        import com.sunild.maps.GHeatMapOverlay;

        import mx.collections.ArrayCollection;
        import mx.events.EffectEvent;

        private function onEffectEnd(event:EffectEvent):void {
            map.removeOverlay((event.target as Fade).target as IOverlay);
        }

        private function onInitialize():void {
            Security.allowInsecureDomain("maps.googleapis.com");
        }

        private var heatMapDefinition:HeatMapDefinition;

        private var overlays:ArrayCollection = new ArrayCollection();

        [Bindable]
        private var dataSet:ArrayCollection;

        private function getMapType(typeVal:int):IMapType {

            switch (typeVal) {
                case 1:
                    return MapType.NORMAL_MAP_TYPE;
                case 2:
                    return MapType.HYBRID_MAP_TYPE;
                case 3:
                    return MapType.SATELLITE_MAP_TYPE;
                case 4:
                    return MapType.PHYSICAL_MAP_TYPE;
                default:
                    return null;
            }
        }

        private function getMapVal(mapType:IMapType):int {
            if (mapType == MapType.NORMAL_MAP_TYPE) {
                return 1;
            }
            if (mapType == MapType.HYBRID_MAP_TYPE) {
                return 2;
            }
            if (mapType == MapType.SATELLITE_MAP_TYPE) {
                return 3;
            }
            if (mapType == MapType.PHYSICAL_MAP_TYPE) {
                return 4;
            }
            return 0;
        }

        private function setBounding():void {
            heatMapDefinition.minLat = map.getLatLngBounds().getNorthWest().lat();
            heatMapDefinition.minLong = map.getLatLngBounds().getNorthWest().lng();
            heatMapDefinition.maxLat = map.getLatLngBounds().getSouthEast().lat();
            heatMapDefinition.maxLong = map.getLatLngBounds().getSouthEast().lng();
        }

        private function onMoveEnd(event:MapMoveEvent):void {
            if (heatMapDefinition != null) {
                heatMapDefinition.latitude = event.latLng.lat();
                heatMapDefinition.longitude = event.latLng.lng();
                setBounding();
            }

        }

        private function onZoomChanged(event:MapZoomEvent):void {
            if (heatMapDefinition != null) {
                heatMapDefinition.zoomLevel = event.zoomLevel;
                setBounding();
            }
        }

        private function onMapTypeChanged(event:MapEvent):void {
            if (heatMapDefinition != null) {
                heatMapDefinition.mapType = getMapVal(map.getCurrentMapType());
            }
        }

        private function onMapReady(event:MapEvent):void {
            map.addControl(new ZoomControl());
            map.addControl(new PositionControl());
            map.addControl(new MapTypeControl());
            map.addEventListener(MapMoveEvent.MOVE_END, onMoveEnd);
            map.addEventListener(MapZoomEvent.ZOOM_CHANGED, onZoomChanged);
            map.addEventListener(MapEvent.MAPTYPE_CHANGED, onMapTypeChanged);
            prepareMap();
        }

        private var lastDisplayType:int;

        private function prepareMap():void {
            for each (var o:Object in overlays) {
                if (lastDisplayType == HeatMapDefinition.HEAT_MAP) {
                    var fadeOutEffect:Fade = new Fade();
                    fadeOutEffect.target = o;
                    fadeOutEffect.alphaFrom = .57;
                    fadeOutEffect.alphaTo = 0.0;
                    fadeOutEffect.duration = 1000;
                    fadeOutEffect.addEventListener(EffectEvent.EFFECT_END, onEffectEnd);
                    fadeOutEffect.play();
                } else {
                    map.removeOverlay(IOverlay(o));
                }
            }
            overlays.removeAll();
            if (heatMapDefinition != null) {
                if (heatMapDefinition.displayType == HeatMapDefinition.HEAT_MAP) {
                    addHeatMap();
                } else {
                    addPointMap();
                }
                lastDisplayType = heatMapDefinition.displayType;
            }

            if (heatMapDefinition != null && heatMapDefinition.mapType != 0) {
                map.setCenter(new LatLng(heatMapDefinition.latitude, heatMapDefinition.longitude), heatMapDefinition.zoomLevel, getMapType(heatMapDefinition.mapType));
            }
            else if (heatMapDefinition != null && map.isLoaded()) {
                heatMapDefinition.latitude = map.getCenter().lat();
                heatMapDefinition.longitude = map.getCenter().lng();
                heatMapDefinition.zoomLevel = map.getZoom();
                heatMapDefinition.mapType = getMapVal(map.getCurrentMapType());
            }

        }

        private var pointDictionary:Dictionary = new Dictionary();

        private function addPointMap():void {
            if (heatMapDefinition != null && dataSet != null) {
                for each (var point:Object in dataSet) {
                    var latLng:LatLng;
                    if (heatMapDefinition.zipCode != null) {
                        var coordinateValue:CoordinateValue = point[heatMapDefinition.zipCode.qualifiedName()];
                        latLng = new LatLng(Number(coordinateValue.y), Number(coordinateValue.x));
                    } else {
                        latLng = new LatLng(Number(point[heatMapDefinition.latitudeItem.qualifiedName()]), Number(point[heatMapDefinition.longitudeItem.qualifiedName()]));
                    }
                    pointDictionary[latLng.lat() + "-" + latLng.lng()] = point;
                    var marker:Marker = new Marker(latLng);

                    marker.addEventListener(MapMouseEvent.CLICK, onEvent);
                    overlays.addItem(marker);
                    map.addOverlay(marker);
                }
            }
        }

        private function onEvent(event:MapMouseEvent):void {
            var marker:Marker = event.currentTarget as Marker;
            var ll:LatLng = marker.getLatLng();
            var lookup:String = ll.lat() + "-" + ll.lng();
            var point:Object = pointDictionary[lookup];
            if (heatMapDefinition.zipCode != null && heatMapDefinition.zipCode.links != null && heatMapDefinition.zipCode.links.length > 0) {
                var link:Link = heatMapDefinition.zipCode.links.getItemAt(0) as Link;
                if (link is DrillThrough) {
                    var executor:DrillThroughExecutor = new DrillThroughExecutor(link as DrillThrough);
                    executor.addEventListener(DrillThroughEvent.DRILL_THROUGH, function(event:DrillThroughEvent):void {
                        var filterDefinition:FilterValueDefinition = new FilterValueDefinition();
                        var coordinateValue:CoordinateValue = point[heatMapDefinition.zipCode.qualifiedName()];
                        filterDefinition.field = heatMapDefinition.getCoreAnalysisItem(heatMapDefinition.zipCode);
                        filterDefinition.filteredValues = new ArrayCollection([coordinateValue.zip]);
                        filterDefinition.enabled = true;
                        filterDefinition.inclusive = true;
                        var filters:ArrayCollection = new ArrayCollection([ filterDefinition ]);
                        if (event.drillThrough.miniWindow) {
                            dispatchEvent(new ReportWindowEvent(event.report.id, 0, 0, filters, event.report.dataFeedID, event.report.reportType));
                        } else {
                            dispatchEvent(new ReportNavigationEvent(ReportNavigationEvent.TO_REPORT, event.report, filters));
                        }
                    });
                    executor.send();
                }
            } else {
                var options:InfoWindowOptions = new InfoWindowOptions();
                options.contentHTML = "<p>" + heatMapDefinition.measure.display + ": <b>" + point[heatMapDefinition.measure.qualifiedName()] + "</b></p>";
                marker.openInfoWindow(options);
            }
            /*var lookup:String = ll.lat() + "-" + ll.lng();
            var obj:Object = pointDictionary[lookup];
            var options:InfoWindowOptions = new InfoWindowOptions();
            options.contentHTML = "<p>" + heatMapDefinition.measure.display + ": <b>" + obj[heatMapDefinition.measure.qualifiedName()] + "</b></p>";
            marker.openInfoWindow(options);*/
        }

        private function addHeatMap():void {
            var heatMap:HeatMap = new HeatMap();
            heatMap.setStyle("backgroundColor", "0");
            heatMap.setStyle("backgroundAlpha", "0");
            heatMap.alpha = 0.57;
            heatMap.gradientArray = GradientDictionary.RAINBOW;
            heatMap.dataProvider = dataSet;
            heatMap.transformationFunction = latLonToPoint;
            heatMap.weightFunction = getCount;
            var overlay:GHeatMapOverlay = new GHeatMapOverlay(heatMap);
            overlay.alpha = 0;
            overlays.addItem(overlay);
            fadeInEffect.target = overlay;
            fadeInEffect.play();
            map.addOverlay(overlay);
            fadeInEffect.target = heatMap;
            fadeInEffect.play();
        }

        public function renderReport(dataSet:ArrayCollection, analysisDefinition:AnalysisDefinition, clientProcessorMap:Object, additionalProperties:Object):void {
            if (dataSet.length > 0) {
                heatMapDefinition = analysisDefinition as HeatMapDefinition;
                var data:ArrayCollection = new ArrayCollection();
                for each (var point:Object in dataSet) {
                    if (heatMapDefinition.zipCode != null) {
                        if (point[heatMapDefinition.zipCode.qualifiedName()] is CoordinateValue) {
                            data.addItem(point);
                        }
                    } else {
                        if (point[heatMapDefinition.longitudeItem.qualifiedName()] != 0 ||
                            point[heatMapDefinition.latitudeItem.qualifiedName()] != 0) {
                            data.addItem(point);
                        }
                    }
                }
                this.dataSet = data;
                if (map.isLoaded()) {
                    prepareMap();
                }
            }
        }

        public function createFilterRawData():FilterRawData {
            return null;
        }

        public function updateExportMetadata():void {
        }

        private function latLonToPoint(o:Object):Object {
            if (heatMapDefinition.zipCode != null) {
                var coordinateValue:CoordinateValue = o[heatMapDefinition.zipCode.qualifiedName()];
                return map.fromLatLngToViewport(new LatLng(Number(coordinateValue.y), Number(coordinateValue.x)));
            } else {
                return map.fromLatLngToViewport(new LatLng(Number(o[heatMapDefinition.latitudeItem.qualifiedName()]), Number(o[heatMapDefinition.longitudeItem.qualifiedName()])));
            }
        }

        private function getCount(o:Object):Number {
            var n:Number = o[heatMapDefinition.measure.qualifiedName()] as Number;
            return n;
        }

        public function preserveValues():Boolean {
            return false;
        }

        public function getPrintableBitmap():Bitmap {
            return map.getPrintableBitmap();
        }

        public function onCustomChangeEvent(event:CustomChangeEvent):void {
        }]]></mx:Script>
    <maps:Map xmlns:maps="com.google.maps.*" id="map" mapevent_mapready="onMapReady(event)" 
  width="100%" height="100%" key="ABQIAAAA2117HwaIOF-a5ho2SalSZxQw7JNcT96mmHPfRfrQHk2xuzdGoxSekTo3OqnayhJZONwWnFdGSn_0HQ"
            sensor="false"/>
</mx:Module>