<?xml version="1.0" encoding="utf-8"?>
<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml"
         horizontalAlign="center" creationComplete="creationCompleteHandler(event)" width="300">
    <mx:Metadata>
        [Event(name="gotMetadataComplete", type="flash.events.Event")]
    </mx:Metadata>
    <mx:Script>
		<![CDATA[
        import com.easyinsight.analysis.AnalysisDefinition;
        import com.easyinsight.analysis.AnalysisItemHandle;
        import com.easyinsight.dashboard.Dashboard;

        import mx.binding.utils.BindingUtils;
        import mx.collections.ArrayCollection;

        import mx.controls.List;
        import mx.events.FlexEvent;
        import mx.events.PropertyChangeEvent;
        import mx.rpc.events.ResultEvent;
        import mx.rpc.remoting.RemoteObject;


        private var strings:ArrayCollection;

        private var _filterValueDefinition:MultiFieldFilterDefinition;

        private var filterTileList:List;

        [Bindable]
        private var sourceValues:ArrayCollection;

        private var _targetValues:ArrayCollection;

        private var realValues:ArrayCollection;


        [Bindable(event="targetValuesChanged")]
        public function get targetValues():ArrayCollection {
            return _targetValues;
        }

        public function set targetValues(value:ArrayCollection):void {
            if (_targetValues == value) return;
            _targetValues = value;
            dispatchEvent(new Event("targetValuesChanged"));
        }


        private var dataService:RemoteObject;

        private function setup():void {
        }

        private var _fields:ArrayCollection;

        public function set fields(value:ArrayCollection):void {
            _fields = value;
        }

        public function set filterValueDefinition(filterValueDefinition:MultiFieldFilterDefinition):void {
            this._filterValueDefinition = filterValueDefinition;
            //
        }

        [Bindable]
        private var includeFilter:Boolean;
        private var _otherFilters:ArrayCollection;

        public function get otherFilters():ArrayCollection {
            return _otherFilters;
        }

        public function set otherFilters(value:ArrayCollection):void {
            _otherFilters = value;
        }

        private var _report:AnalysisDefinition;

        private var _dashboard:Dashboard;

        private var _filterSet:FilterSet;

        public function set filterSet(value:FilterSet):void {
            _filterSet = value;
        }

        public function set report(value:AnalysisDefinition):void {
            _report = value;
        }

        public function set dashboard(value:Dashboard):void {
            _dashboard = value;
        }

        override protected function commitProperties():void {
            super.commitProperties();
            dataService = new RemoteObject();
            dataService.destination = "data";
            dataService.possibleFields.addEventListener(ResultEvent.RESULT, gotMetadata);
            dataService.possibleFields.send(_filterValueDefinition, _report, _dashboard, _filterSet);
        }

        /*private static function compare(obj1:Object, obj2:Object, fields:Array = null):int {
         var string1:String = obj1 as String;
         var string2:String = obj2 as String;
         return ObjectUtil.stringCompare(string1, string2, true);
         }*/

        private function gotMetadata(event:ResultEvent):void {
            var fields:ArrayCollection = dataService.possibleFields.lastResult as
                    ArrayCollection;
            var filteredStrings:ArrayCollection = new ArrayCollection();

            /*var o:Object = new Object();
             for each (var selected:AnalysisItemHandle in MultiFieldFilterDefinition(_filterValueDefinition).selectedItems) {
             o[selected.analysisItemID] = true;
             }*/
            strings = new ArrayCollection();
            for each (var analysisItem:AnalysisItemSelection in fields) {
                strings.addItem(analysisItem);
            }
            /*strings.sort = new Sort();
             strings.sort.compareFunction = compare;*/
            sourceValues = strings;
            /*filteredStrings.sort = new Sort();
             filteredStrings.sort.compareFunction = compare;*/
//            filteredStrings.filterFunction = targetFilterFunction;
            filteredStrings.refresh();

            var all:Boolean = _filterValueDefinition.all;
            allCheckBox.selected = all;

            loadedValuesBox.addChild(filterTileList);

            var a:Array = strings.toArray().map(function (obj:Object, a:*, b:*):Object {
                var m:MultiFieldFilterOption = new MultiFieldFilterOption(obj as AnalysisItemSelection, obj.selected || all);
                m.addEventListener("selectedChanged", valueChanged, false, 0, true);
                return m;
            });

            realValues = new ArrayCollection(a);
            targetValues = new ArrayCollection(a);
            targetValues.filterFunction = valuesFilterFunction;
            stackIndex = 1;
        }

        private function valueChanged(event:PropertyChangeEvent):void {
            if (event.newValue == false && allCheckBox.selected) {
                allCheckBox.selected = false;
            } else if (event.newValue == true) {
                var b:Boolean = true;
                for each(var v:* in realValues) {
                    if (!v.selected)
                        b = false;
                }
                if (b) {
                    allCheckBox.selected = true;
                }
            }
        }

        private function sourceChange():void {
            sourceValues.refresh();
        }

        private function includedChange():void {
            targetValues.refresh();
        }

        private var _includedKeyword:String;

        public function get includedKeyword():String {
            return _includedKeyword;
        }

        public function set includedKeyword(value:String):void {
            _includedKeyword = value;
        }

        private var _keyword:String;

        public function get keyword():String {
            return _keyword;
        }

        public function set keyword(value:String):void {
            _keyword = value;
        }

        public function makeUpdates():FilterDefinition {
            var valueFilter:MultiFieldFilterDefinition = _filterValueDefinition as MultiFieldFilterDefinition;
            var a:Array = realValues.toArray().concat();
            /*a = a.filter(function (obj:Object, a:*, b:*):Boolean {
             return obj.selected;
             });*/

            valueFilter.fieldOrdering = new ArrayCollection(a.map(function (obj:Object, a:*, b:*):Object {
                var handle1:AnalysisItemHandle = new AnalysisItemHandle();
                handle1.name = obj.analysisItem.display;
                return handle1;
            }));

            if (allCheckBox.selected) {
                valueFilter.all = true;
                valueFilter.selectedItems = new ArrayCollection();
            } else {
                var i:int = 0;
                valueFilter.all = false;
                valueFilter.selectedItems = new ArrayCollection(a.map(function (obj:Object, a:*, b:*):Object {
                    var handle:AnalysisItemHandle = new AnalysisItemHandle();
                    handle.analysisItemID = obj.analysisItem.analysisItemID;
                    handle.name = obj.analysisItem.display;
                    handle.selected = obj.selected;
                    return handle;
                }));
            }

            for each (var v:AnalysisItemHandle in valueFilter.selectedItems) {
                //targetValues.getItemIndex();
                // find the index for each selected item...
            }

            return _filterValueDefinition;
        }

        public function set filterDefinition(filterDefinition:FilterDefinition):void {
            _filterValueDefinition = filterDefinition as MultiFieldFilterDefinition;
        }

        private function addAll():void {
            var values:Array = sourceValues.toArray();
            for each (var o:* in values) {
                targetValues.addItem(o);
            }
            sourceValues.removeAll();
        }

        private function removeAll():void {
            var values:Array = targetValues.toArray();
            for each (var o:* in values) {
                sourceValues.addItem(o);
            }
            targetValues.removeAll();
        }

        [Bindable]
        private var stackIndex:int = 0;

        private var _typeChangeAllowed:Boolean = true;

        [Bindable(event="typeChangeAllowedChanged")]
        public function get typeChangeAllowed():Boolean {
            return _typeChangeAllowed;
        }

        public function set typeChangeAllowed(value:Boolean):void {
            if (_typeChangeAllowed == value) return;
            _typeChangeAllowed = value;
            dispatchEvent(new Event("typeChangeAllowedChanged"));
        }

        private var filterString:String = "";

        private var allCheckBox:CheckBox;

        private var selectedFilter:Boolean;

        private function valuesFilterFunction(o:Object):Boolean {
            var result:Boolean = true;
            if (selectedFilter) {
                result = (o.selected as Boolean);
            }
            return result && (o.label as String).toLowerCase().indexOf(filterString.toLowerCase()) != -1;
        }

        private function filterBox_changeHandler(event:Event):void {
            filterString = filterBox.text;
            filterTileList.dataProvider.refresh();
            loadedValuesBox.addChild(filterTileList);
        }

        private function creationCompleteHandler(event:FlexEvent):void {
            filterTileList = new List();
            filterTileList.id = "solutionGrid";
            filterTileList.itemRenderer = new ClassFactory(FilterStringCheckbox);
            filterTileList.dragEnabled = true;
            filterTileList.dropEnabled = true;
            filterTileList.dragMoveEnabled = true;
            filterTileList.columnWidth = 150;
            filterTileList.rowHeight = 30;
            filterTileList.verticalScrollPolicy = "on";
            filterTileList.columnCount = 1;
            filterTileList.percentWidth = 100;
            allCheckBox = new CheckBox();
            allCheckBox.label = "All";
            allCheckBox.addEventListener(Event.CHANGE, allCheckBox_changeHandler);

            BindingUtils.bindProperty(filterTileList, "dataProvider", this, "targetValues");
        }

        private function allCheckBox_changeHandler(event:Event):void {
            var b:Boolean = allCheckBox.selected;
            for each(var a:* in realValues) {
                a.selected = b;
            }
        }

        private function selectedFilterEvent(event:Event):void {
            selectedFilter = selectedFilterCheckBox.selected;
            filterTileList.dataProvider.refresh();
            loadedValuesBox.addChild(filterTileList);
        }

        private function addLoadedBox(event:FlexEvent):void {
            loadedValuesBox.addChildAt(allCheckBox, 0);
            loadedValuesBox.addChild(filterTileList);
        }
        ]]>
	</mx:Script>
    <mx:HBox width="100%">
        <mx:Image source="@Embed('../../../../assets/icon-search-black.png')"/>
        <mx:TextInput id="filterBox" width="100%" change="filterBox_changeHandler(event)"/>
    </mx:HBox>
    <mx:HBox>
        <mx:CheckBox id="selectedFilterCheckBox" change="selectedFilterEvent(event)" label="Show only selected values"/>
    </mx:HBox>
    <mx:ViewStack resizeToContent="true" selectedIndex="{stackIndex}" width="100%">
        <mx:Box>
            <mx:ProgressBar label="Loading the available values..." indeterminate="true"/>
        </mx:Box>

        <mx:VBox id="loadedValuesBox" creationComplete="addLoadedBox(event)">

        </mx:VBox>

    </mx:ViewStack>
</mx:VBox>
